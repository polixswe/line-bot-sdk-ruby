#!/usr/bin/env ruby
# frozen_string_literal: true

require 'fileutils'

#############################################
# メイン処理
#############################################
def main
  # ==== 1) 対象ディレクトリを指定し、そこから *.rb を検索 ====
  target_dir = './lib/line/bot/v2' # 例: "./clients" ディレクトリを探索
  client_files = fetch_client_files(target_dir)

  # ==== 2) 各ファイルを解析し、クラス情報・メソッド情報を得る ====
  clients_info = client_files.map { |file| parse_client_file(file) }.compact

  # ==== 3) "合体クライアント" を生成する ====
  aggregator_code = generate_aggregator_code(clients_info)

  # ==== 4) 出力 (標準出力に吐き出す)====
  puts aggregator_code
end

#############################################
# 指定ディレクトリ以下から client.rb を再帰的に取得
#############################################
def fetch_client_files(dir)
  Dir[File.join(dir, '**', '*_client.rb')]
end

#############################################
# クラスファイルを読み込み、以下を返す:
# {
#   class_name: "Line::Bot::V2::Foo::ApiClient",
#   instance_var: "@foo_api_client",        # guess_instance_var_name(class_name)
#   methods: [
#     {
#       doc_lines: ["# ...", "# ..."],      # メソッド直前に連なるドキュメントコメント (元のインデントごと)
#       def_block:  ["def ...", "  ...", "end"], # def〜endのすべて (配列)
#       method_name: "some_method_name"
#     }, ...
#   ]
# }
#############################################
def parse_client_file(file_path)
  lines = File.read(file_path).lines
  mod_stack = []
  full_class_name = nil

  methods = []
  doc_buffer = []

  # メソッド関連
  inside_method = false
  current_def_lines = []
  current_def_leading_spaces = nil

  lines.each do |line|
    stripped = line.strip
    leading_spaces = line[/^\s*/] || ""

    case stripped
    when /^module\s+([\w:]+)/
      mod_stack << $1
    when /^class\s+([\w:]+)/
      mod_stack << $1
      full_class_name = mod_stack.join('::')
    when /^end\b/
      # モジュール/クラス終了
      mod_stack.pop if mod_stack.any?

      # メソッド終端の可能性
      if inside_method && leading_spaces == current_def_leading_spaces
        # 今のメソッドを確定
        current_def_lines << line # "end"
        inside_method = false
        # メソッド解析 (initialize は除外)
        def_header = current_def_lines.first.strip  # 例: "def some_method ..."
        if !def_header.start_with?("def initialize")
          # メソッド名をパース
          method_name = parse_method_name(def_header)
          methods << {
            doc_lines: doc_buffer.dup,   # 直前のdocコメントをコピー
            def_block: current_def_lines.map(&:rstrip), # 全行(インデント含む)を右端の空白除去だけして保持
            method_name: method_name
          }
        end
        # 後始末
        doc_buffer.clear
        current_def_lines = []
        current_def_leading_spaces = nil
      end

    when /^def\s+/
      # メソッド開始
      inside_method = true
      current_def_leading_spaces = leading_spaces
      current_def_lines = [line]
    else
      if inside_method
        # メソッドの中身を取り込む
        current_def_lines << line
      else
        # メソッド外 => docコメントが来たら doc_buffer に貯める
        if stripped.start_with?('#')
          doc_buffer << line.rstrip
        else
          # コメント以外なら doc_buffer はリセット
          doc_buffer.clear
        end
      end
    end
  end

  return nil unless full_class_name

  {
    class_name: full_class_name,
    instance_var: guess_instance_var_name(full_class_name),
    methods: methods
  }
rescue => e
  warn "Failed to parse #{file_path}: #{e}"
  nil
end

#############################################
# クラス名からインスタンス変数名を推定(ユニーク化用)
#  例: "Line::Bot::V2::MessagingApi::ApiBlobClient"
#   1) 先頭の "Line::Bot::V2::" を除去
#   2) "::" を "_" に置換
#   3) CamelCase => snake_case
#   => "@messaging_api_api_blob_client"
#############################################
def guess_instance_var_name(full_class_name)
  name = full_class_name.dup
  name.sub!(/^Line::Bot::V2::/, '')     # 先頭のLine::Bot::V2::を取り除く (任意)
  name.gsub!('::', '_')                # "::" → "_"

  # CamelCaseをスネークケースへ (簡易な実装)
  name = name.
    gsub(/([A-Z\d]+)([A-Z][a-z])/, '\1_\2').
    gsub(/([a-z\d])([A-Z])/, '\1_\2').
    downcase

  "@#{name}"
end

#############################################
# def行からメソッド名を取り出す
#  例: "def gets_all_valid_channel_access_token_key_ids_with_http_info(" 
#    => "gets_all_valid_channel_access_token_key_ids_with_http_info"
#############################################
def parse_method_name(def_header_line)
  # "def ..." の後ろの単語を抽出
  if def_header_line =~ /^def\s+([\w!?]+)/ 
    return $1
  end
  'unknown_method'
end

#############################################
# 複数クライアントの情報から "合体クライアント" のコードを生成
#############################################
def generate_aggregator_code(clients_info)
  <<~RUBY
    # This file is auto-generated by the merge script.
    # It combines multiple clients into a single aggregator client that delegates each method.

    module Line
      module Bot
        module V2
          class AllInOneClient
            # Initializes a new AllInOneClient
            #
            # この例では:
            # - base_url, http_options を通常用に
            # - base_url_for_blob, http_options_for_blob を Blob 用に
            # - base_url_for_module_attach, http_options_for_module_attach を ModuleAttach 用に
            # - channel_access_token, channel_id, channel_secret などもまとめて受け取る
            def initialize(
              base_url: nil,
              base_url_for_blob: nil,
              base_url_for_module_attach: nil,
              channel_access_token: nil,
              channel_id: nil,
              channel_secret: nil,
              http_options: {},
              http_options_for_blob: {},
              http_options_for_module_attach: {}
            )
    #{generate_initializations(clients_info).indent(14)}
            end

    #{generate_delegation_methods(clients_info).indent(12)}
          end
        end
      end
    end
  RUBY
end

#############################################
# 全クライアントの初期化行を生成する
#   クラス名に "Blob" が含まれれば base_url_for_blob を使うなどの例
#############################################
def generate_initializations(clients_info)
  lines = []
  used_vars = {}  # 重複インスタンス変数チェック用 (同一class_nameなら同じvar名を使う)

  clients_info.each do |info|
    class_name = info[:class_name]
    ivar       = info[:instance_var]

    # もし同一クラス名が複数ある場合、インスタンス変数名が衝突しないよう制御
    if used_vars[ivar]
      # 衝突回避(例えば同じクラスファイルが何かの都合で2回パースされる場合など)
      n = 2
      new_ivar = ivar + "_#{n}"
      while used_vars[new_ivar]
        n += 1
        new_ivar = ivar + "_#{n}"
      end
      ivar = new_ivar
    end
    used_vars[ivar] = true

    init_call = if class_name.include?('Blob')
      "#{ivar} = #{class_name}.new(base_url: base_url_for_blob, channel_access_token: channel_access_token, http_options: http_options_for_blob)"
    elsif class_name.include?('ModuleAttach')
      "#{ivar} = #{class_name}.new(base_url: base_url_for_module_attach, channel_id: channel_id, channel_secret: channel_secret, http_options: http_options_for_module_attach)"
    else
      "#{ivar} = #{class_name}.new(base_url: base_url, channel_access_token: channel_access_token, http_options: http_options)"
    end

    lines << "  #{init_call}"
  end

  lines.join("\n")
end

#############################################
# 各メソッドのデリゲート定義を生成
#   - docコメントと def行〜end行のヘッダ・引数・end行のインデントをそのまま再現しつつ
#   - 中身だけ "@xxx_client.method(...)" に置き換える
#############################################
def generate_delegation_methods(clients_info)
  code = []

  clients_info.each do |info|
    ivar = info[:instance_var]

    info[:methods].each do |meth|
      doc_lines   = meth[:doc_lines]
      def_block   = meth[:def_block]   # 配列: ["  def ...", "    (引数)", "    本文...", "  end"]
      method_name = meth[:method_name]

      # ドキュメントコメントは丸ごと出力
      code.concat doc_lines

      # def〜endブロックを解析し、メソッド引数部分を抽出 → デフォルト値含め丸コピー
      # 例：   def attach_module_with_http_info(
      #          grant_type:,
      #          code: nil
      #        )
      #        本文...
      #        end
      # 
      # → def attach_module_with_http_info(
      #      grant_type:,
      #      code: nil
      #    )
      #    @xxx_client.attach_module_with_http_info(
      #      grant_type: grant_type,
      #      code: code
      #    )
      # end

      # 1) def行を出力 (そのまま)
      code << def_block.first

      # 2) 引数定義が続く行（"def" の次行から、同じインデントレベルの行 or "end" が出るまで）を出力
      #    ※ ここではインデント同じ行が「メソッド本体の始まり」かもしれないので判定が難しいが、
      #      一般的に `)`, `) # comment` が出たら引数終了、とみなす簡易実装。
      #    ※ 生成物のフォーマットが厳密に決まっている前提（1行1キーワードなど）ならもっと単純に行けます。
      #    ともかく def〜end をまるっと見て、 def行 と end行 を除いた“真ん中”を
      #    「引数定義部分 + 本文部分」に分割し、前半が引数、後半をdelegateに差し替える。
      
      # def行 & end行 を除いた中身
      middle_lines = def_block[1..-2] # 本文・引数を含む
      # end行
      end_line = def_block.last

      # "引数部分" と "本文部分" を分割する。
      # ここでは非常に単純に、')' を含む行の直後までを"引数部分"とみなす。 
      # 以降を"本文部分"。
      arg_part = []
      body_part = []
      done_arg = false

      middle_lines.each do |ln|
        if !done_arg
          arg_part << ln
          if ln.strip.end_with?(')') || ln.strip =~ /\)\s*(#.*)?$/
            # 引数定義ここで終了
            done_arg = true
          end
        else
          body_part << ln
        end
      end

      # 引数部分はそのまま出力
      code.concat arg_part

      # delegate 呼び出しを挿入
      # ここでは「引数部分からキーワードリストを抽出」→ "@ivar.method_name( kw1: kw1, kw2: kw2 )" を作る
      # （あくまで複数行に1キーワードずつ書かれている前提でざっくりパース）
      kwarg_lines = extract_kwarg_lines_from_arg_part(arg_part)
      # delegate 呼び出しのインデント: 本文先頭行があればそれに合わせる（なければ def行 + 2スペース など）
      delegate_indent = body_part.first ? body_part.first[/^\s*/] : (def_block.first[/^\s*/] + '  ')

      # 出力
      code << "#{delegate_indent}#{ivar}.#{method_name}("
      kwarg_lines.each_with_index do |kw, idx|
        comma = (idx < kwarg_lines.size - 1) ? ',' : ''
        code << "#{delegate_indent}  #{kw}#{comma}"
      end
      code << "#{delegate_indent})"

      # 4) end行
      code << end_line
      code << ""  # メソッド間の空行
    end
  end

  code.join("\n")
end

#############################################
# 引数パートの行から "kw: default" の形を抽出し、
# デリゲート呼び出し用に "kw: kw" の行配列を返す
#############################################
def extract_kwarg_lines_from_arg_part(arg_part_lines)
  # 例:
  #   "    (grant_type:, "
  #   "     code: 'default',"
  #   "     redirect_uri:,"
  #   "     x_line_retry_key: nil)"
  # のような行から
  #   ["grant_type:", "code: 'default'", "redirect_uri:", "x_line_retry_key: nil"]
  # を取り出す(カンマは除去)
  # → delegate呼び出しでは
  #   "grant_type: grant_type, code: code, ..." のようにしたいので
  #    "grant_type:" → "grant_type: grant_type"
  #    "code: 'default'" → "code: code"
  #    ... ただし default 値があるかどうかにかかわらず
  #    "param: anything" => "param: param"
  # となる。

  # 1) 全行をつなぎ、括弧など取り除き、カンマでsplit…も可。ただし“かっこいい感じ”に整形された生成物前提なら、
  #    行ごとに /^(\s*)(\w+):.*(,?)$/ のような正規表現で抽出でもOK。
  #    ここでは行ごとに単純に抜き出す。

  pattern = /^\s*([\w]+):([^,)]*)(,?)/
  results = []

  arg_part_lines.each do |ln|
    # ln例: "     code: 'default',"
    while ln =~ pattern
      param_name = $1   # "code"
      _rest      = $2   # " 'default'"
      # 末尾のカンマは $3
      # 行からマッチ部分を切り取る
      ln = ln.sub(pattern, '') 
      # "code: 'default'"
      results << "#{param_name}: #{"#{param_name}"}"
    end
  end

  results
end

#############################################
# String に便利メソッド: 指定スペースだけインデント
#############################################
class String
  def indent(count)
    gsub(/^/, ' ' * count)
  end
end

# 実行
main if __FILE__ == $PROGRAM_NAME