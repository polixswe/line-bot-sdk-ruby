#!/usr/bin/env ruby
# frozen_string_literal: true

require 'fileutils'
require 'json'

#############################################
# メイン処理
#############################################
def main
  # ==== 1) 対象のディレクトリを指定し、そこから *.rb を検索 ====
  target_dir = './lib' # 例として "./lib" ディレクトリ
  client_files = fetch_client_files(target_dir)

  # ==== 2) 各ファイルをパースし、クラス情報を得る ====
  clients_info = client_files.map do |file|
    parse_client_file(file)
  end.compact

  # ==== 3) "合体クライアント" を生成する ====
  aggregator_code = generate_aggregator_code(clients_info)

  # ==== 4) 出力 ====
  # 標準出力に吐き出す例
  puts aggregator_code
end

#############################################
# 指定ディレクトリ以下から client.rb を再帰的に取得
#############################################
def fetch_client_files(dir)
  # パターンとしては **/client.rb を探す
  Dir[File.join(dir, '**', '*client.rb')]
end

#############################################
# ファイルを読み込み、クラス名・インスタンス変数名・メソッド定義を抽出
#############################################
def parse_client_file(file_path)
  lines = File.read(file_path).lines

  full_class_name = nil
  mod_stack = []

  methods = []
  doc_buffer = []

  # パース状態
  inside_method = false
  current_method_indent = nil
  current_method_signature_line = nil
  current_method_lines = []

  lines.each do |line|
    # 行頭の空白を取得
    leading_spaces = line[/^\s*/]
    stripped = line.strip

    case stripped
    when /^module\s+([\w:]+)/
      # 例: "module Line" => モジュールをスタックに積む
      mod_stack << $1
    when /^class\s+([\w:]+)/
      mod_stack << $1
      full_class_name = mod_stack.join('::')
    when /^end\b/
      # 最後に積んだモジュール or クラス
      mod_stack.pop if mod_stack.any?

      # メソッドパース中ならこれがメソッドのendか判定
      if inside_method && leading_spaces == current_method_indent
        # メソッド終了
        # initialize は除外する
        if !current_method_signature_line.include?('initialize')
          # doc_buffer + current_method_lines が 1メソッド
          methods << {
            doc_lines: doc_buffer.dup,
            signature_line: current_method_signature_line,
            body_lines: current_method_lines[1..-1], # 最初の行は def シグニチャと被るので除外
          }
        end
        # 後処理
        doc_buffer.clear
        current_method_signature_line = nil
        current_method_lines.clear
        inside_method = false
        current_method_indent = nil
      end

    when /^def\s+(.+)/
      # メソッド開始
      inside_method = true
      current_method_indent = leading_spaces
      current_method_signature_line = line.chomp
      current_method_lines = [line.chomp]

    else
      # それ以外の行
      if inside_method
        # メソッド本体として格納
        current_method_lines << line.chomp
      else
        # メソッドの外 => コメントなら doc_buffer に貯める (インデントも揃う前提)
        if stripped.start_with?('#')
          doc_buffer << line.chomp
        else
          # コメント以外が来たら doc_buffer をクリア (別のまとまりとみなす)
          doc_buffer.clear
        end
      end
    end
  end

  # インスタンス変数名を自動生成
  instance_var = guess_instance_var_name(full_class_name)

  {
    class_name: full_class_name,
    instance_var: instance_var,
    methods: methods
  }
rescue => e
  warn "Failed to parse #{file_path} => #{e}"
  nil
end

#############################################
# クラス名からインスタンス変数名を推定
#   例: "Line::Bot::V2::MessagingApi::ApiClient" => "@messaging_api_client"
#############################################
def guess_instance_var_name(full_class_name)
  return '@unknown_client' unless full_class_name

  # クラス名の最後の部分だけ見る
  # 例: "...::MessagingApi::ApiClient" => "ApiClient"
  leaf_name = full_class_name.split('::').last

  # "ApiClient" => "api_client"
  # "ApiBlobClient" => "api_blob_client" などを想定
  # 大文字→区切りの簡易スネークケース変換 (簡易)
  var_base = leaf_name.
               gsub(/([A-Z]+)([A-Z][a-z])/, '\1_\2').
               gsub(/([a-z\d])([A-Z])/, '\1_\2').
               downcase

  "@#{var_base}"
end

#############################################
# 複数クライアントの情報から "合体クライアント" のコードを生成
#############################################
def generate_aggregator_code(clients_info)
  <<~RUBY
    # This file is auto-generated by the merge script.
    # It combines multiple clients into a single aggregator client that delegates each method.

    module Line
      module Bot
        module V2
          class AllInOneClient
            # Initializes a new AllInOneClient
            #
            # この例では:
            # - base_url, http_options を通常用に
            # - base_url_for_blob, http_options_for_blob を Blob 用に
            # - base_url_for_module_attach, http_options_for_module_attach を ModuleAttach 用に
            # - channel_access_token, channel_id, channel_secret などもまとめて受け取る
            def initialize(
              base_url: nil,
              base_url_for_blob: nil,
              base_url_for_module_attach: nil,
              channel_access_token: nil,
              channel_id: nil,
              channel_secret: nil,
              http_options: {},
              http_options_for_blob: {},
              http_options_for_module_attach: {}
            )
    #{generate_initializations(clients_info).indent(14)}
            end

    #{generate_delegation_methods(clients_info).indent(12)}
          end
        end
      end
    end
  RUBY
end

#############################################
# 各クライアントを初期化する行を生成
#############################################
def generate_initializations(clients_info)
  lines = clients_info.map do |info|
    class_name = info[:class_name] || 'UnknownClass'
    ivar = info[:instance_var] || '@unknown_client'

    # 簡易ロジック: Class 名に Blob が含まれるかなどで初期化引数を分岐
    # ここは実際の要件にあわせてカスタマイズしてください
    if class_name&.include?('Blob')
      "  #{ivar} = #{class_name}.new(base_url: base_url_for_blob, channel_access_token: channel_access_token, http_options: http_options_for_blob)"
    elsif class_name&.include?('ModuleAttach')
      "  #{ivar} = #{class_name}.new(base_url: base_url_for_module_attach, channel_id: channel_id, channel_secret: channel_secret, http_options: http_options_for_module_attach)"
    else
      "  #{ivar} = #{class_name}.new(base_url: base_url, channel_access_token: channel_access_token, http_options: http_options)"
    end
  end

  lines.join("\n")
end

#############################################
# 各メソッドの “delegate” メソッド定義部分を生成
#############################################
def generate_delegation_methods(clients_info)
  code = []

  clients_info.each do |info|
    ivar = info[:instance_var] || '@unknown_client'
    info[:methods].each do |meth|
      doc_lines = meth[:doc_lines]
      signature_line = meth[:signature_line]
      # body_lines = meth[:body_lines]  # ここでは実際の実装コードは不要で、delegate だけにする

      # ドキュメントコメント
      doc_lines.each do |doc|
        code << "      #{doc}"
      end

      # def attach_module_with_http_info( ... )
      code << "      #{signature_line}"

      # delegate呼び出しの生成
      #   (キーワードをまるっとコピー)
      #   例: def attach_module_with_http_info(
      #          grant_type:,
      #          code:,
      #          ...
      #        )
      #        @module_attach_client.attach_module_with_http_info(
      #          grant_type: grant_type,
      #          code: code,
      #          ...
      #        )
      #      end

      # “signature_line” から引数部分だけをうまく取り出す (インデント頼みでパース)
      # 前提: 以下のように複数行にわたっても最終的に全て同じインデントで閉じられる
      #   def method_name(
      #     a:,
      #     b: nil
      #   )
      # なので、一度 signature_line 含め、次の行以降にも引数があるかどうかは
      # “generate_kwarg_call” のロジックでまとめて処理する手もあり。
      # ここでは非常に単純な実装をします。

      # 仮: 1行に全部書いてある前提なら => /^def\s+\w+\((.*)\)$/ でマッチ、など。
      # しかしサンプルでは複数行にわたる想定なので、本来は行数が必要。
      # => テンプレートが一貫したインデントなので、最終的には “end” 行の同じインデントになるまで読み続ける方法もある。

      # ただし、今回の例では「行頭の def ... から行頭の end」までが1メソッドと分かっており、
      # かつ「引数はすべて signature_line に含まれる or 次行以降も同じインデントで定義される」想定をしている。
      # “meth[:body_lines]” からメソッド定義部分だけ取り出せばよい。
      kwarg_lines = extract_kwarg_lines(meth)

      code << "        #{ivar}.#{method_name(signature_line)}("
      kwarg_lines.each_with_index do |kw, i|
        code << "          #{kw}#{i < kwarg_lines.size - 1 ? ',' : ''}"
      end
      code << "        )"
      code << "      end\n\n"
    end
  end

  code.join("\n")
end

#############################################
# 引数キーワードの行を抽出する (インデントを頼りに簡易に行う)
#   - meth[:signature_line], meth[:body_lines] から
#   - “def ... (行の後続) や改行されたキーワード部分” のみ拾う
#   - "grant_type:" → "grant_type: grant_type"
#   - "code:,"      → "code: code"
#############################################
def extract_kwarg_lines(meth)
  # まず signature_line にキーワードが載っている場合を取得
  #   例: def attach_module_with_http_info( # steep:ignore ...
  #          grant_type:,
  #          code:,
  #          ...
  #        )
  #        ↑ signature_line は1行分しかない場合あり(最初の行)。
  #          本当は body_lines も含めてパースすべき
  # ただ、本スクリプトでは**「関数定義のキーワードはすべて別行に書かれる」**という前提を活かし、
  # meth[:body_lines] のうち “def 〜” 行から “)“ までが引数定義部分、と決め打ちする例を示します。

  # メソッド定義の行たち
  def_lines = meth[:body_lines].unshift(meth[:signature_line])

  # “end” or 本体記述が始まる前の行までをピックアップ
  # ここでは “) ” で終わる行までを「引数定義」とみなす(大雑把)
  arg_lines = []
  def_lines.each do |ln|
    break if ln.strip.end_with?(')')
    arg_lines << ln
  end

  # 取得した行から、キーワード部分だけ取り出す
  # 例: `            x_line_retry_key: nil,`
  #     `            broadcast_request:,`
  # このあたりはシンプルに正規表現で行う例
  kwarg_pattern = /^\s*([\w]+:.*)$/

  # "grant_type:,", "code: nil," などをキャプチャ
  raw_kws = arg_lines.map { |ln| ln.strip }.select { |l| l =~ kwarg_pattern }

  # delegate用に変換
  #   "grant_type:" => "grant_type: grant_type"
  #   "code: nil," => "code: code"
  raw_kws.map do |kw|
    # 末尾のカンマは落とす
    kw = kw.sub(/,\s*$/, '')
    name = kw.split(':').first.strip # "grant_type"
    "#{name}: #{name}"
  end
end

#############################################
# メソッド名だけ抜き出す
#   例: "def attach_module_with_http_info(" → "attach_module_with_http_info"
#############################################
def method_name(signature_line)
  # `def attach_module_with_http_info(` からメソッド名を抜き出す
  # /^def\s+(\S+)/ でOK (ただし括弧が続くかもしれないので)
  if signature_line =~ /^\s*def\s+([\w!?]+)/ 
    return $1
  end
  'unknown_method'
end

#############################################
# String に便利メソッド: インデントを付与
#############################################
class String
  def indent(num_spaces)
    gsub(/^/, ' ' * num_spaces)
  end
end


# 実行
main if __FILE__ == $PROGRAM_NAME
